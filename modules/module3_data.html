<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Matrices and Arrays</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Matrices and Arrays</h1>

<p>If you need to do numeric calculations on an entire non-vector object (dimension &gt; 1), you generally want to use matrices and arrays, not data frames.</p>

<ul>
<li>Matrices are two-dimensional collections of values of the same type</li>
<li>We can have numeric, integer, character, or logical matrices, character matrices.</li>
<li>You can&#39;t mix types within a matrix</li>
</ul>

<pre><code class="r">mat &lt;- matrix(rnorm(12), nrow = 3, ncol = 4)
mat
</code></pre>

<pre><code>##            [,1]       [,2]       [,3]        [,4]
## [1,] -0.8204684  0.5757814  0.3898432  1.12493092
## [2,]  0.4874291 -0.3053884 -0.6212406 -0.04493361
## [3,]  0.7383247  1.5117812 -2.2146999 -0.01619026
</code></pre>

<pre><code class="r"># vectorized calcs work with matrices too
mat*4
</code></pre>

<pre><code>##           [,1]      [,2]      [,3]        [,4]
## [1,] -3.281874  2.303125  1.559373  4.49972367
## [2,]  1.949716 -1.221554 -2.484962 -0.17973444
## [3,]  2.953299  6.047125 -8.858800 -0.06476105
</code></pre>

<pre><code class="r">mat &lt;- cbind(mat, 1:3)
mat
</code></pre>

<pre><code>##            [,1]       [,2]       [,3]        [,4] [,5]
## [1,] -0.8204684  0.5757814  0.3898432  1.12493092    1
## [2,]  0.4874291 -0.3053884 -0.6212406 -0.04493361    2
## [3,]  0.7383247  1.5117812 -2.2146999 -0.01619026    3
</code></pre>

<pre><code class="r"># Let&#39;s convert the gapminder dataframe to a matrix:
gm_mat &lt;- as.matrix(gap[ , c(&#39;lifeExp&#39;, &#39;gdpPercap&#39;)])
head(gm_mat)
</code></pre>

<pre><code>##      lifeExp gdpPercap
## [1,]  28.801  779.4453
## [2,]  30.332  820.8530
## [3,]  31.997  853.1007
## [4,]  34.020  836.1971
## [5,]  36.088  739.9811
## [6,]  38.438  786.1134
</code></pre>

<pre><code class="r"># What do you think will happen?
gm_mat &lt;- as.matrix(gap)
head(gm_mat)
</code></pre>

<pre><code>##      country       year   pop          continent lifeExp    gdpPercap    
## [1,] &quot;Afghanistan&quot; &quot;1952&quot; &quot;   8425333&quot; &quot;Asia&quot;    &quot;28.80100&quot; &quot;   779.4453&quot;
## [2,] &quot;Afghanistan&quot; &quot;1957&quot; &quot;   9240934&quot; &quot;Asia&quot;    &quot;30.33200&quot; &quot;   820.8530&quot;
## [3,] &quot;Afghanistan&quot; &quot;1962&quot; &quot;  10267083&quot; &quot;Asia&quot;    &quot;31.99700&quot; &quot;   853.1007&quot;
## [4,] &quot;Afghanistan&quot; &quot;1967&quot; &quot;  11537966&quot; &quot;Asia&quot;    &quot;34.02000&quot; &quot;   836.1971&quot;
## [5,] &quot;Afghanistan&quot; &quot;1972&quot; &quot;  13079460&quot; &quot;Asia&quot;    &quot;36.08800&quot; &quot;   739.9811&quot;
## [6,] &quot;Afghanistan&quot; &quot;1977&quot; &quot;  14880372&quot; &quot;Asia&quot;    &quot;38.43800&quot; &quot;   786.1134&quot;
</code></pre>

<p>Arrays are like matrices but can have more or fewer than two dimensions.</p>

<pre><code class="r">arr &lt;- array(rnorm(12), c(2, 3, 4))
arr
</code></pre>

<pre><code>## , , 1
## 
##           [,1]      [,2]       [,3]
## [1,] 0.9438362 0.5939013 0.78213630
## [2,] 0.8212212 0.9189774 0.07456498
## 
## , , 2
## 
##            [,1]        [,2]       [,3]
## [1,] -1.9893517 -0.05612874 -1.4707524
## [2,]  0.6198257 -0.15579551 -0.4781501
## 
## , , 3
## 
##           [,1]      [,2]       [,3]
## [1,] 0.9438362 0.5939013 0.78213630
## [2,] 0.8212212 0.9189774 0.07456498
## 
## , , 4
## 
##            [,1]        [,2]       [,3]
## [1,] -1.9893517 -0.05612874 -1.4707524
## [2,]  0.6198257 -0.15579551 -0.4781501
</code></pre>

<h1>Attributes</h1>

<p>Objects have <em>attributes</em>.</p>

<pre><code class="r">attributes(mat)
</code></pre>

<pre><code>## $dim
## [1] 3 5
</code></pre>

<pre><code class="r">rownames(mat) &lt;- c(&#39;first&#39;, &#39;middle&#39;, &#39;last&#39;)
mat
</code></pre>

<pre><code>##              [,1]       [,2]       [,3]        [,4] [,5]
## first  -0.8204684  0.5757814  0.3898432  1.12493092    1
## middle  0.4874291 -0.3053884 -0.6212406 -0.04493361    2
## last    0.7383247  1.5117812 -2.2146999 -0.01619026    3
</code></pre>

<pre><code class="r">attributes(mat)
</code></pre>

<pre><code>## $dim
## [1] 3 5
## 
## $dimnames
## $dimnames[[1]]
## [1] &quot;first&quot;  &quot;middle&quot; &quot;last&quot;  
## 
## $dimnames[[2]]
## NULL
</code></pre>

<pre><code class="r">names(attributes(gap))
</code></pre>

<pre><code>## [1] &quot;names&quot;     &quot;class&quot;     &quot;row.names&quot;
</code></pre>

<pre><code class="r">attributes(gap)$names
</code></pre>

<pre><code>## [1] &quot;country&quot;   &quot;year&quot;      &quot;pop&quot;       &quot;continent&quot; &quot;lifeExp&quot;   &quot;gdpPercap&quot;
</code></pre>

<pre><code class="r">attributes(gap)$row.names[1:10]
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<p>Now let&#39;s do a bit of manipulation and see if you can infer how R represents matrices internally.</p>

<pre><code class="r">mat[4]
</code></pre>

<pre><code>## [1] 0.5757814
</code></pre>

<pre><code class="r">attributes(mat) &lt;- NULL
mat
</code></pre>

<pre><code>##  [1] -0.82046838  0.48742905  0.73832471  0.57578135 -0.30538839
##  [6]  1.51178117  0.38984324 -0.62124058 -2.21469989  1.12493092
## [11] -0.04493361 -0.01619026  1.00000000  2.00000000  3.00000000
</code></pre>

<pre><code class="r">is.matrix(mat)
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p><strong>Question</strong>: What can you infer about what a matrix is in R?</p>

<p><strong>Question</strong>: What kind of object are the attributes themselves? How do I check?</p>

<h1>Matrices are stored column-major</h1>

<p>This is like Fortran, MATLAB and Julia but not like C or Python(numpy). </p>

<pre><code class="r">mat &lt;- matrix(1:12, 3, 4)
mat
</code></pre>

<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
</code></pre>

<pre><code class="r">c(mat)
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12
</code></pre>

<p>You can go smoothly back and forth between a matrix (or an array) and a vector:</p>

<pre><code class="r">identical(mat, matrix(c(mat), 3, 4))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">identical(mat, matrix(c(mat), 3, 4, byrow = TRUE))
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>This is a common cause of bugs!</p>

<h1>Missing values and other special values</h1>

<p>Since it was designed by statisticians, R handles missing values very well relative to other languages.</p>

<ul>
<li><code>NA</code> is a missing value</li>
</ul>

<pre><code class="r">vec &lt;- rnorm(12)
vec[c(3, 5)] &lt;- NA
vec
</code></pre>

<pre><code>##  [1]  0.4179416  1.3586796         NA  0.3876716         NA -1.3770596
##  [7] -0.4149946 -0.3942900 -0.0593134  1.1000254  0.7631757 -0.1645236
</code></pre>

<pre><code class="r">length(vec)
</code></pre>

<pre><code>## [1] 12
</code></pre>

<pre><code class="r">sum(vec)
</code></pre>

<pre><code>## [1] NA
</code></pre>

<pre><code class="r">sum(vec, na.rm = TRUE)
</code></pre>

<pre><code>## [1] 1.617313
</code></pre>

<pre><code class="r">hist(vec)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/></p>

<pre><code class="r">is.na(vec)
</code></pre>

<pre><code>##  [1] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE
</code></pre>

<p>Be careful because many R functions won&#39;t warn you that they are ignoring the missing values.</p>

<ul>
<li>To infinity and beyond</li>
</ul>

<pre><code class="r">big &lt;- 1e500 
big
</code></pre>

<pre><code>## [1] Inf
</code></pre>

<pre><code class="r">big + 7
</code></pre>

<pre><code>## [1] Inf
</code></pre>

<ul>
<li><code>NaN</code> stands for Not a Number</li>
</ul>

<pre><code class="r">sqrt(-5)
</code></pre>

<pre><code>## Warning in sqrt(-5): NaNs produced
</code></pre>

<pre><code>## [1] NaN
</code></pre>

<pre><code class="r">big - big
</code></pre>

<pre><code>## [1] NaN
</code></pre>

<pre><code class="r">1/0
</code></pre>

<pre><code>## [1] Inf
</code></pre>

<ul>
<li><code>NULL</code></li>
</ul>

<pre><code class="r">vec &lt;- c(vec, NULL) 
vec
</code></pre>

<pre><code>##  [1]  0.4179416  1.3586796         NA  0.3876716         NA -1.3770596
##  [7] -0.4149946 -0.3942900 -0.0593134  1.1000254  0.7631757 -0.1645236
</code></pre>

<pre><code class="r">length(vec)
</code></pre>

<pre><code>## [1] 12
</code></pre>

<pre><code class="r">a &lt;- NULL
a + 7
</code></pre>

<pre><code>## numeric(0)
</code></pre>

<pre><code class="r">a[3, 4]
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r">is.null(a)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">myList &lt;- list(a = 7, b = 5)
myList$a &lt;- NULL  # works for data frames too
myList
</code></pre>

<pre><code>## $b
## [1] 5
</code></pre>

<p><code>NA</code> can hold a place but <code>NULL</code> cannot.
<code>NULL</code> is useful for having a function argument default to &#39;nothing&#39;. See <code>help(crossprod)</code>, which can compute either \(X^{\top}X\) or \(X^{\top}Y\).  </p>

<h1>Logical vectors</h1>

<pre><code class="r">gap2007 &lt;- gap[gap$year == 2007, ]

wealthy &lt;- gap2007$gdpPercap &gt; 35000
healthy &lt;- gap2007$lifeExp &gt; 75

head(wealthy)
</code></pre>

<pre><code>## [1] FALSE FALSE FALSE FALSE FALSE FALSE
</code></pre>

<pre><code class="r">table(wealthy)
</code></pre>

<pre><code>## wealthy
## FALSE  TRUE 
##   130    12
</code></pre>

<pre><code class="r"># note the vectorized boolean arithmetic
gap2007[wealthy &amp; healthy, ]
</code></pre>

<pre><code>##              country year       pop continent lifeExp gdpPercap
## 84           Austria 2007   8199783    Europe  79.829  36126.49
## 252           Canada 2007  33390141  Americas  80.653  36319.24
## 420          Denmark 2007   5468120    Europe  78.332  35278.42
## 672  Hong Kong China 2007   6980412      Asia  82.208  39724.98
## 696          Iceland 2007    301931    Europe  81.757  36180.79
## 756          Ireland 2007   4109086    Europe  78.885  40676.00
## 864           Kuwait 2007   2505559      Asia  77.588  47306.99
## 1092     Netherlands 2007  16570613    Europe  79.762  36797.93
## 1152          Norway 2007   4627926    Europe  80.196  49357.19
## 1368       Singapore 2007   4553009      Asia  79.972  47143.18
## 1488     Switzerland 2007   7554661    Europe  81.701  37506.42
## 1620   United States 2007 301139947  Americas  78.242  42951.65
</code></pre>

<pre><code class="r">gap2007[wealthy | healthy, ]
</code></pre>

<pre><code>##              country year       pop continent lifeExp gdpPercap
## 24           Albania 2007   3600523    Europe  76.423  5937.030
## 60         Argentina 2007  40301927  Americas  75.320 12779.380
## 72         Australia 2007  20434176   Oceania  81.235 34435.367
## 84           Austria 2007   8199783    Europe  79.829 36126.493
## 96           Bahrain 2007    708573      Asia  75.635 29796.048
## 120          Belgium 2007  10392226    Europe  79.441 33692.605
## 252           Canada 2007  33390141  Americas  80.653 36319.235
## 288            Chile 2007  16284741  Americas  78.553 13171.639
## 360       Costa Rica 2007   4133884  Americas  78.782  9645.061
## 384          Croatia 2007   4493312    Europe  75.748 14619.223
## 396             Cuba 2007  11416987  Americas  78.273  8948.103
## 408   Czech Republic 2007  10228744    Europe  76.486 22833.309
## 420          Denmark 2007   5468120    Europe  78.332 35278.419
## 528          Finland 2007   5238460    Europe  79.313 33207.084
## 540           France 2007  61083916    Europe  80.657 30470.017
## 576          Germany 2007  82400996    Europe  79.406 32170.374
## 600           Greece 2007  10706290    Europe  79.483 27538.412
## 672  Hong Kong China 2007   6980412      Asia  82.208 39724.979
## 696          Iceland 2007    301931    Europe  81.757 36180.789
## 756          Ireland 2007   4109086    Europe  78.885 40675.996
## 768           Israel 2007   6426679      Asia  80.745 25523.277
## 780            Italy 2007  58147733    Europe  80.546 28569.720
## 804            Japan 2007 127467972      Asia  82.603 31656.068
## 852       Korea Rep. 2007  49044790      Asia  78.623 23348.140
## 864           Kuwait 2007   2505559      Asia  77.588 47306.990
## 996           Mexico 2007 108700891  Americas  76.195 11977.575
## 1092     Netherlands 2007  16570613    Europe  79.762 36797.933
## 1104     New Zealand 2007   4115771   Oceania  80.204 25185.009
## 1152          Norway 2007   4627926    Europe  80.196 49357.190
## 1164            Oman 2007   3204897      Asia  75.640 22316.193
## 1188          Panama 2007   3242173  Americas  75.537  9809.186
## 1236          Poland 2007  38518241    Europe  75.563 15389.925
## 1248        Portugal 2007  10642836    Europe  78.098 20509.648
## 1260     Puerto Rico 2007   3942491  Americas  78.746 19328.709
## 1272         Reunion 2007    798094    Africa  76.442  7670.123
## 1368       Singapore 2007   4553009      Asia  79.972 47143.180
## 1392        Slovenia 2007   2009245    Europe  77.926 25768.258
## 1428           Spain 2007  40448191    Europe  80.941 28821.064
## 1476          Sweden 2007   9031088    Europe  80.884 33859.748
## 1488     Switzerland 2007   7554661    Europe  81.701 37506.419
## 1512          Taiwan 2007  23174294      Asia  78.400 28718.277
## 1608  United Kingdom 2007  60776238    Europe  79.425 33203.261
## 1620   United States 2007 301139947  Americas  78.242 42951.653
## 1632         Uruguay 2007   3447496  Americas  76.384 10611.463
</code></pre>

<pre><code class="r">gap2007[wealthy &amp; !healthy, ]
</code></pre>

<pre><code>## [1] country   year      pop       continent lifeExp   gdpPercap
## &lt;0 rows&gt; (or 0-length row.names)
</code></pre>

<pre><code class="r"># what am I doing here?
sum(healthy)
</code></pre>

<pre><code>## [1] 44
</code></pre>

<pre><code class="r">mean(healthy)
</code></pre>

<pre><code>## [1] 0.3098592
</code></pre>

<p><strong>Question</strong>: What do you think R is doing to do arithmetic on logical vectors?</p>

<p>Tricks with logicals&hellip;</p>

<pre><code class="r">identical(healthy &amp; wealthy, as.logical(healthy * wealthy))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">identical(healthy | wealthy, as.logical(healthy + wealthy))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h1>Data frames</h1>

<p>A review from Module 1&hellip;</p>

<ul>
<li>Data frames are combinations of vectors of the same length, but can be of different types</li>
<li>Data frames are what is used for standard rectangular (record by field) datasets, similar to a spreadsheet</li>
<li>Data frames are a functionality that both sets R aside from some languages (e.g., Matlab) and provides functionality similar to some statistical packages (e.g., Stata, SAS)</li>
</ul>

<pre><code class="r">class(gap)
</code></pre>

<pre><code>## [1] &quot;data.frame&quot;
</code></pre>

<pre><code class="r">head(gap)
</code></pre>

<pre><code>##       country year      pop continent lifeExp gdpPercap
## 1 Afghanistan 1952  8425333      Asia  28.801  779.4453
## 2 Afghanistan 1957  9240934      Asia  30.332  820.8530
## 3 Afghanistan 1962 10267083      Asia  31.997  853.1007
## 4 Afghanistan 1967 11537966      Asia  34.020  836.1971
## 5 Afghanistan 1972 13079460      Asia  36.088  739.9811
## 6 Afghanistan 1977 14880372      Asia  38.438  786.1134
</code></pre>

<pre><code class="r">str(gap)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    1704 obs. of  6 variables:
##  $ country  : chr  &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ...
##  $ year     : int  1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...
##  $ pop      : num  8425333 9240934 10267083 11537966 13079460 ...
##  $ continent: chr  &quot;Asia&quot; &quot;Asia&quot; &quot;Asia&quot; &quot;Asia&quot; ...
##  $ lifeExp  : num  28.8 30.3 32 34 36.1 ...
##  $ gdpPercap: num  779 821 853 836 740 ...
</code></pre>

<h1>Data frames are (special) lists!</h1>

<pre><code class="r">is.list(gap)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">length(gap)
</code></pre>

<pre><code>## [1] 6
</code></pre>

<pre><code class="r">gap[[3]][1:5]
</code></pre>

<pre><code>## [1]  8425333  9240934 10267083 11537966 13079460
</code></pre>

<pre><code class="r">lapply(gap, class) 
</code></pre>

<pre><code>## $country
## [1] &quot;character&quot;
## 
## $year
## [1] &quot;integer&quot;
## 
## $pop
## [1] &quot;numeric&quot;
## 
## $continent
## [1] &quot;character&quot;
## 
## $lifeExp
## [1] &quot;numeric&quot;
## 
## $gdpPercap
## [1] &quot;numeric&quot;
</code></pre>

<p><code>lapply()</code> is a function used on lists; it works here to apply the <code>class()</code> function to each element of the list, which in this case is each field/column.</p>

<h1>But lists are also vectors!</h1>

<pre><code class="r">length(gap)
</code></pre>

<pre><code>## [1] 6
</code></pre>

<pre><code class="r">someFields &lt;- gap[c(3,5)]
head(someFields)
</code></pre>

<pre><code>##        pop lifeExp
## 1  8425333  28.801
## 2  9240934  30.332
## 3 10267083  31.997
## 4 11537966  34.020
## 5 13079460  36.088
## 6 14880372  38.438
</code></pre>

<pre><code class="r">identical(gap[c(3,5)], gap[ , c(3,5)])
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>In general the placement of commas in R is crucial, but here, two different operations give the same result because of the underlying structure of data frames.</p>

<h1>Factors</h1>

<ul>
<li>A factor is a special data type in R used for categorical data. In some cases it works like magic and in others it is incredibly frustrating. </li>
</ul>

<pre><code class="r">## let&#39;s read the Gapminder data in using the defaults for `read.csv`
gap &lt;- read.csv(file.path(&#39;..&#39;, &#39;data&#39;, &#39;gapminder-FiveYearData.csv&#39;))
class(gap$continent)
</code></pre>

<pre><code>## [1] &quot;factor&quot;
</code></pre>

<pre><code class="r">head(gap$continent) # What order are the factors in?
</code></pre>

<pre><code>## [1] Asia Asia Asia Asia Asia Asia
## Levels: Africa Americas Asia Europe Oceania
</code></pre>

<pre><code class="r">levels(gap[[&quot;continent&quot;]])  # note alternate way to get the variable
</code></pre>

<pre><code>## [1] &quot;Africa&quot;   &quot;Americas&quot; &quot;Asia&quot;     &quot;Europe&quot;   &quot;Oceania&quot;
</code></pre>

<pre><code class="r">summary(gap$continent)
</code></pre>

<pre><code>##   Africa Americas     Asia   Europe  Oceania 
##      624      300      396      360       24
</code></pre>

<ul>
<li>What if we don&#39;t like the order these are in? Factor order is important for all kinds of things like plotting, analysis of variance, regression output, and more</li>
</ul>

<h1>Ordering the Factor</h1>

<ul>
<li>Ordered factors simply have an additional attribute explaining the order of the levels of a factor</li>
<li>This is a useful shortcut when we want to preserve some of the meaning provided by the order</li>
<li>Think ordinal data</li>
</ul>

<p>This example is a bit artificial as &#39;continent&#39; doesn&#39;t really have a natural ordering.</p>

<pre><code class="r">gap$continent2 &lt;- ordered(gap$continent, 
     levels = levels(gap$continent)[c(2,1,3,4,5)])

head(gap$continent2)
</code></pre>

<pre><code>## [1] Asia Asia Asia Asia Asia Asia
## Levels: Americas &lt; Africa &lt; Asia &lt; Europe &lt; Oceania
</code></pre>

<pre><code class="r">levels(gap$continent2)
</code></pre>

<pre><code>## [1] &quot;Americas&quot; &quot;Africa&quot;   &quot;Asia&quot;     &quot;Europe&quot;   &quot;Oceania&quot;
</code></pre>

<pre><code class="r">boxplot(lifeExp ~ continent2, data = gap)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/></p>

<h1>Reclassifying Factors</h1>

<ul>
<li>Turning factors into other data types can be tricky. All factors have an underlying numeric structure.</li>
</ul>

<pre><code class="r">students &lt;- factor(c(&#39;basic&#39;,&#39;proficient&#39;,&#39;advanced&#39;,&#39;basic&#39;, 
      &#39;advanced&#39;, &#39;minimal&#39;))
levels(students)
</code></pre>

<pre><code>## [1] &quot;advanced&quot;   &quot;basic&quot;      &quot;minimal&quot;    &quot;proficient&quot;
</code></pre>

<pre><code class="r">unclass(students)
</code></pre>

<pre><code>## [1] 2 4 1 2 1 3
## attr(,&quot;levels&quot;)
## [1] &quot;advanced&quot;   &quot;basic&quot;      &quot;minimal&quot;    &quot;proficient&quot;
</code></pre>

<ul>
<li>Hmmm, what happened?</li>
<li>Be careful! The best way to convert a factor is to convert it to a character first.</li>
</ul>

<pre><code class="r">students &lt;- factor(c(&#39;basic&#39;,&#39;proficient&#39;,&#39;advanced&#39;,&#39;basic&#39;, 
      &#39;advanced&#39;, &#39;minimal&#39;))
score = c(minimal = 3, basic = 1, advanced = 13, proficient = 7) # a named vector
score[&quot;advanced&quot;]  # look up by name
</code></pre>

<pre><code>## advanced 
##       13
</code></pre>

<pre><code class="r">students[3]
</code></pre>

<pre><code>## [1] advanced
## Levels: advanced basic minimal proficient
</code></pre>

<pre><code class="r">score[students[3]]
</code></pre>

<pre><code>## minimal 
##       3
</code></pre>

<pre><code class="r">score[as.character(students[3])]
</code></pre>

<pre><code>## advanced 
##       13
</code></pre>

<p>What went wrong and how did we fix it?  Notice how easily this could be a big bug in your code.</p>

<h1>Subsetting</h1>

<p>There are many ways to select subsets in R. The syntax below is useful for vectors, matrices, data frames, arrays and lists.</p>

<pre><code class="r">vec &lt;- gap2007$lifeExp
mat &lt;- matrix(1:20, 4, 5)
rownames(mat) &lt;- letters[1:4]
mat
</code></pre>

<pre><code>##   [,1] [,2] [,3] [,4] [,5]
## a    1    5    9   13   17
## b    2    6   10   14   18
## c    3    7   11   15   19
## d    4    8   12   16   20
</code></pre>

<p>1) by direct indexing</p>

<pre><code class="r">vec[c(3, 5, 12:14)]
</code></pre>

<pre><code>## [1] 72.301 75.320 65.554 74.852 50.728
</code></pre>

<pre><code class="r">vec[-c(3,5)]
</code></pre>

<pre><code>##   [1] 43.828 76.423 42.731 81.235 79.829 75.635 64.062 79.441 56.728 65.554
##  [11] 74.852 50.728 72.390 73.005 52.295 49.580 59.723 50.430 80.653 44.741
##  [21] 50.651 78.553 72.961 72.889 65.152 46.462 55.322 78.782 48.328 75.748
##  [31] 78.273 76.486 78.332 54.791 72.235 74.994 71.338 71.878 51.579 58.040
##  [41] 52.947 79.313 80.657 56.735 59.448 79.406 60.022 79.483 70.259 56.007
##  [51] 46.388 60.916 70.198 82.208 73.338 81.757 64.698 70.650 70.964 59.545
##  [61] 78.885 80.745 80.546 72.567 82.603 72.535 54.110 67.297 78.623 77.588
##  [71] 71.993 42.592 45.678 73.952 59.443 48.303 74.241 54.467 64.164 72.801
##  [81] 76.195 66.803 74.543 71.164 42.082 62.069 52.906 63.785 79.762 80.204
##  [91] 72.899 56.867 46.859 80.196 75.640 65.483 75.537 71.752 71.421 71.688
## [101] 75.563 78.098 78.746 76.442 72.476 46.242 65.528 72.777 63.062 74.002
## [111] 42.568 79.972 74.663 77.926 48.159 49.339 80.941 72.396 58.556 39.613
## [121] 80.884 81.701 74.143 78.400 52.517 70.616 58.420 69.819 73.923 71.777
## [131] 51.542 79.425 78.242 76.384 73.747 74.249 73.422 62.698 42.384 43.487
</code></pre>

<pre><code class="r">gap[c(2,4), 5]
</code></pre>

<pre><code>## [1] 30.332 34.020
</code></pre>

<pre><code class="r">gap[c(2,4), &#39;lifeExp&#39;]
</code></pre>

<pre><code>## [1] 30.332 34.020
</code></pre>

<pre><code class="r">rowInd &lt;- c(1, 3, 4)
colInd &lt;- c(2, 2, 1)
elemInd &lt;- cbind(rowInd, colInd)
elemInd
</code></pre>

<pre><code>##      rowInd colInd
## [1,]      1      2
## [2,]      3      2
## [3,]      4      1
</code></pre>

<pre><code class="r">gap[elemInd]
</code></pre>

<pre><code>## [1] &quot;1952&quot;        &quot;1962&quot;        &quot;Afghanistan&quot;
</code></pre>

<p>Note the last usage where we give it a 2-column matrix of indices</p>

<p>2) by a vector of logicals</p>

<pre><code class="r">wealthy &lt;- gap$gdpPercap &gt; 50000
gap$gdpPercap[wealthy]
</code></pre>

<pre><code>## [1] 108382.35 113523.13  95458.11  80894.88 109347.87  59265.48
</code></pre>

<pre><code class="r">gap[wealthy, ]
</code></pre>

<pre><code>##     country year     pop continent lifeExp gdpPercap continent2
## 853  Kuwait 1952  160000      Asia  55.565 108382.35       Asia
## 854  Kuwait 1957  212846      Asia  58.033 113523.13       Asia
## 855  Kuwait 1962  358266      Asia  60.470  95458.11       Asia
## 856  Kuwait 1967  575003      Asia  64.624  80894.88       Asia
## 857  Kuwait 1972  841934      Asia  67.712 109347.87       Asia
## 858  Kuwait 1977 1140357      Asia  69.343  59265.48       Asia
</code></pre>

<p>What happened in the last subsetting operation?</p>

<p>3) by a vector of names</p>

<pre><code class="r">mat[c(&#39;a&#39;, &#39;d&#39;, &#39;a&#39;), ]
</code></pre>

<pre><code>##   [,1] [,2] [,3] [,4] [,5]
## a    1    5    9   13   17
## d    4    8   12   16   20
## a    1    5    9   13   17
</code></pre>

<p>4) using <em>subset()</em></p>

<pre><code class="r">subset(gap, gdpPercap &gt; 50000)
</code></pre>

<pre><code>##     country year     pop continent lifeExp gdpPercap continent2
## 853  Kuwait 1952  160000      Asia  55.565 108382.35       Asia
## 854  Kuwait 1957  212846      Asia  58.033 113523.13       Asia
## 855  Kuwait 1962  358266      Asia  60.470  95458.11       Asia
## 856  Kuwait 1967  575003      Asia  64.624  80894.88       Asia
## 857  Kuwait 1972  841934      Asia  67.712 109347.87       Asia
## 858  Kuwait 1977 1140357      Asia  69.343  59265.48       Asia
</code></pre>

<p>5) using <em>dplyr</em> tools such as <em>filter()</em> and <em>select()</em> &ndash; more in Module 6</p>

<h1>Assignment into subsets</h1>

<p>We can assign into subsets by using similar syntax, as we saw with vectors.</p>

<pre><code class="r">vec &lt;- rnorm(20)
vec[c(3, 5, 12:14)] &lt;- 1:5
vec
</code></pre>

<pre><code>##  [1] -0.2533617  0.6969634  1.0000000 -0.6887557  2.0000000  0.3645820
##  [7]  0.7685329 -0.1123462  0.8811077  0.3981059 -0.6120264  3.0000000
## [13]  4.0000000  5.0000000  1.9803999 -0.3672215 -1.0441346  0.5697196
## [19] -0.1350546  2.4016178
</code></pre>

<pre><code class="r">mat[2, 3:5] &lt;- rnorm(3)
mat[mat[,1] &gt; 0, ] &lt;- -Inf
mat
</code></pre>

<pre><code>##   [,1] [,2] [,3] [,4] [,5]
## a -Inf -Inf -Inf -Inf -Inf
## b -Inf -Inf -Inf -Inf -Inf
## c -Inf -Inf -Inf -Inf -Inf
## d -Inf -Inf -Inf -Inf -Inf
</code></pre>

<h1>Strings</h1>

<p>R has lots of functionality for character strings. Usually these are stored as vectors of strings, each with arbitrary length.</p>

<pre><code class="r">chars &lt;- c(&#39;hi&#39;, &#39;hallo&#39;, &quot;mother&#39;s&quot;, &#39;father\&#39;s&#39;, &quot;He said, \&quot;hi\&quot;&quot; )
length(chars)
</code></pre>

<pre><code>## [1] 5
</code></pre>

<pre><code class="r">nchar(chars)
</code></pre>

<pre><code>## [1]  2  5  8  8 13
</code></pre>

<pre><code class="r">paste(&quot;bill&quot;, &quot;clinton&quot;, sep = &quot; &quot;)  # paste together a set of strings
</code></pre>

<pre><code>## [1] &quot;bill clinton&quot;
</code></pre>

<pre><code class="r">paste(chars, collapse = &#39; &#39;)  # paste together things from a vector
</code></pre>

<pre><code>## [1] &quot;hi hallo mother&#39;s father&#39;s He said, \&quot;hi\&quot;&quot;
</code></pre>

<pre><code class="r">strsplit(&quot;This is the Summer Bridge R&quot;, split = &quot; &quot;)
</code></pre>

<pre><code>## [[1]]
## [1] &quot;This&quot;   &quot;is&quot;     &quot;the&quot;    &quot;Summer&quot; &quot;Bridge&quot; &quot;R&quot;
</code></pre>

<pre><code class="r">countries &lt;- as.character(gap2007$country)
substring(countries, 1, 3)
</code></pre>

<pre><code>##   [1] &quot;Afg&quot; &quot;Alb&quot; &quot;Alg&quot; &quot;Ang&quot; &quot;Arg&quot; &quot;Aus&quot; &quot;Aus&quot; &quot;Bah&quot; &quot;Ban&quot; &quot;Bel&quot; &quot;Ben&quot;
##  [12] &quot;Bol&quot; &quot;Bos&quot; &quot;Bot&quot; &quot;Bra&quot; &quot;Bul&quot; &quot;Bur&quot; &quot;Bur&quot; &quot;Cam&quot; &quot;Cam&quot; &quot;Can&quot; &quot;Cen&quot;
##  [23] &quot;Cha&quot; &quot;Chi&quot; &quot;Chi&quot; &quot;Col&quot; &quot;Com&quot; &quot;Con&quot; &quot;Con&quot; &quot;Cos&quot; &quot;Cot&quot; &quot;Cro&quot; &quot;Cub&quot;
##  [34] &quot;Cze&quot; &quot;Den&quot; &quot;Dji&quot; &quot;Dom&quot; &quot;Ecu&quot; &quot;Egy&quot; &quot;El &quot; &quot;Equ&quot; &quot;Eri&quot; &quot;Eth&quot; &quot;Fin&quot;
##  [45] &quot;Fra&quot; &quot;Gab&quot; &quot;Gam&quot; &quot;Ger&quot; &quot;Gha&quot; &quot;Gre&quot; &quot;Gua&quot; &quot;Gui&quot; &quot;Gui&quot; &quot;Hai&quot; &quot;Hon&quot;
##  [56] &quot;Hon&quot; &quot;Hun&quot; &quot;Ice&quot; &quot;Ind&quot; &quot;Ind&quot; &quot;Ira&quot; &quot;Ira&quot; &quot;Ire&quot; &quot;Isr&quot; &quot;Ita&quot; &quot;Jam&quot;
##  [67] &quot;Jap&quot; &quot;Jor&quot; &quot;Ken&quot; &quot;Kor&quot; &quot;Kor&quot; &quot;Kuw&quot; &quot;Leb&quot; &quot;Les&quot; &quot;Lib&quot; &quot;Lib&quot; &quot;Mad&quot;
##  [78] &quot;Mal&quot; &quot;Mal&quot; &quot;Mal&quot; &quot;Mau&quot; &quot;Mau&quot; &quot;Mex&quot; &quot;Mon&quot; &quot;Mon&quot; &quot;Mor&quot; &quot;Moz&quot; &quot;Mya&quot;
##  [89] &quot;Nam&quot; &quot;Nep&quot; &quot;Net&quot; &quot;New&quot; &quot;Nic&quot; &quot;Nig&quot; &quot;Nig&quot; &quot;Nor&quot; &quot;Oma&quot; &quot;Pak&quot; &quot;Pan&quot;
## [100] &quot;Par&quot; &quot;Per&quot; &quot;Phi&quot; &quot;Pol&quot; &quot;Por&quot; &quot;Pue&quot; &quot;Reu&quot; &quot;Rom&quot; &quot;Rwa&quot; &quot;Sao&quot; &quot;Sau&quot;
## [111] &quot;Sen&quot; &quot;Ser&quot; &quot;Sie&quot; &quot;Sin&quot; &quot;Slo&quot; &quot;Slo&quot; &quot;Som&quot; &quot;Sou&quot; &quot;Spa&quot; &quot;Sri&quot; &quot;Sud&quot;
## [122] &quot;Swa&quot; &quot;Swe&quot; &quot;Swi&quot; &quot;Syr&quot; &quot;Tai&quot; &quot;Tan&quot; &quot;Tha&quot; &quot;Tog&quot; &quot;Tri&quot; &quot;Tun&quot; &quot;Tur&quot;
## [133] &quot;Uga&quot; &quot;Uni&quot; &quot;Uni&quot; &quot;Uru&quot; &quot;Ven&quot; &quot;Vie&quot; &quot;Wes&quot; &quot;Yem&quot; &quot;Zam&quot; &quot;Zim&quot;
</code></pre>

<pre><code class="r">tmp &lt;- countries
substring(tmp, 5, 10) &lt;- &quot;______&quot;
tmp[1:20]
</code></pre>

<pre><code>##  [1] &quot;Afgh______n&quot;            &quot;Alba___&quot;               
##  [3] &quot;Alge___&quot;                &quot;Ango__&quot;                
##  [5] &quot;Arge_____&quot;              &quot;Aust_____&quot;             
##  [7] &quot;Aust___&quot;                &quot;Bahr___&quot;               
##  [9] &quot;Bang______&quot;             &quot;Belg___&quot;               
## [11] &quot;Beni_&quot;                  &quot;Boli___&quot;               
## [13] &quot;Bosn______ Herzegovina&quot; &quot;Bots____&quot;              
## [15] &quot;Braz__&quot;                 &quot;Bulg____&quot;              
## [17] &quot;Burk______so&quot;           &quot;Buru___&quot;               
## [19] &quot;Camb____&quot;               &quot;Came____&quot;
</code></pre>

<p>We can search for patterns in character vectors and replace patterns (both vectorized!)</p>

<pre><code class="r">indexes &lt;- grep(&quot;Korea&quot;, countries)
indexes
</code></pre>

<pre><code>## [1] 70 71
</code></pre>

<pre><code class="r">countries[indexes]
</code></pre>

<pre><code>## [1] &quot;Korea Dem. Rep.&quot; &quot;Korea Rep.&quot;
</code></pre>

<pre><code class="r">countries2 &lt;- gsub(&quot;Korea Dem. Rep.&quot;, &quot;North Korea&quot;, countries)
countries2[indexes]
</code></pre>

<pre><code>## [1] &quot;North Korea&quot; &quot;Korea Rep.&quot;
</code></pre>

<h1>Regular expressions (regex or regexp)</h1>

<p>Some of you may be familiar with using <em>regular expressions</em>, which is functionality for doing sophisticated pattern matching and replacement with strings. <em>Python</em> and <em>Perl</em> are both used extensively for such text manipulation. </p>

<p>R has a full set of regular expression capabilities available through the <em>grep()</em>, <em>gregexpr()</em>, and <em>gsub()</em> functions (among others - many R functions will work with regular expressions). A particularly nice way to make use of this functionality is to use the <em>stringr</em> package, which is more user-friendly than directly using the core R functions.</p>

<p>You can basically do any regular expression/string manipulations in R, though the syntax may be a bit clunky at times.</p>

<h1>Dates</h1>

<ul>
<li>R has built-in ways to handle dates (don&#39;t reinvent the wheel!) </li>
</ul>

<pre><code class="r">date1 &lt;- as.Date(&quot;03-01-2011&quot;, format = &quot;%m-%d-%Y&quot;)
date2 &lt;- as.Date(&quot;03/02/11&quot;, format = &quot;%m/%d/%y&quot;)
date3 &lt;- as.Date(&quot;07-May-11&quot;, format = &quot;%d-%b-%y&quot;)

date1; date2
</code></pre>

<pre><code>## [1] &quot;2011-03-01&quot;
</code></pre>

<pre><code>## [1] &quot;2011-03-02&quot;
</code></pre>

<pre><code class="r">class(date1)
</code></pre>

<pre><code>## [1] &quot;Date&quot;
</code></pre>

<pre><code class="r">dates &lt;- c(date1, date2, date3)
weekdays(dates)
</code></pre>

<pre><code>## [1] &quot;Tuesday&quot;   &quot;Wednesday&quot; &quot;Saturday&quot;
</code></pre>

<pre><code class="r">dates + 30
</code></pre>

<pre><code>## [1] &quot;2011-03-31&quot; &quot;2011-04-01&quot; &quot;2011-06-06&quot;
</code></pre>

<pre><code class="r">date3 - date2
</code></pre>

<pre><code>## Time difference of 66 days
</code></pre>

<pre><code class="r">unclass(dates)
</code></pre>

<pre><code>## [1] 15034 15035 15101
</code></pre>

<ul>
<li>The origin date in R is January 1, 1970</li>
</ul>

<h1>Time too!</h1>

<pre><code class="r">library(chron)
d1 &lt;- chron(&quot;12/25/2004&quot;, &quot;10:37:59&quot;) 
# default format of m/d/Y and h:m:s
d2 &lt;- chron(&quot;12/26/2004&quot;, &quot;11:37:59&quot;)

class(d1)
</code></pre>

<pre><code>## [1] &quot;chron&quot; &quot;dates&quot; &quot;times&quot;
</code></pre>

<pre><code class="r">d1
</code></pre>

<pre><code>## [1] (12/25/04 10:37:59)
</code></pre>

<pre><code class="r">d1 + 33
</code></pre>

<pre><code>## [1] (01/27/05 10:37:59)
</code></pre>

<pre><code class="r">d2 - d1
</code></pre>

<pre><code>## Time in days:
## [1] 1.041667
</code></pre>

<pre><code class="r">d1 + d2
</code></pre>

<pre><code>## Error in Ops.dates(d1, d2): chron objects may not be added together
</code></pre>

<p>There&#39;s lots more packages/functionality for dates/times: see <em>lubridate</em> and <code>?DateTimeClasses</code></p>

<h1>Distributions</h1>

<p>Since R was developed by statisticians, it handles distributions and simulation seamlessly.</p>

<p>All commonly-used distributions have functions in R. Each distribution has a family of functions: </p>

<ul>
<li>d - probability density/mass function, e.g. <code>dnorm()</code></li>
<li>r - generate a random value, e.g., <code>rnorm()</code></li>
<li>p - cumulative distribution function, e.g., <code>pnorm()</code></li>
<li>q - quantile function (inverse CDF), e.g., <code>qnorm()</code></li>
</ul>

<p>Some of the distributions include the following (in the form of their random number generator function): <code>rnorm()</code>, <code>runif()</code>, <code>rbinom()</code>, <code>rpois()</code>, <code>rbeta()</code>, <code>rgamma()</code>, <code>rt()</code>, <code>rchisq()</code>.</p>

<h1>Distributions in action</h1>

<pre><code class="r">pnorm(1.96)
</code></pre>

<pre><code>## [1] 0.9750021
</code></pre>

<pre><code class="r">qnorm(.975)
</code></pre>

<pre><code>## [1] 1.959964
</code></pre>

<pre><code class="r">dbinom(0:10, size = 10, prob = 0.3)
</code></pre>

<pre><code>##  [1] 0.0282475249 0.1210608210 0.2334744405 0.2668279320 0.2001209490
##  [6] 0.1029193452 0.0367569090 0.0090016920 0.0014467005 0.0001377810
## [11] 0.0000059049
</code></pre>

<pre><code class="r">dnorm(5)
</code></pre>

<pre><code>## [1] 1.48672e-06
</code></pre>

<pre><code class="r">dt(5, df = 1)
</code></pre>

<pre><code>## [1] 0.01224269
</code></pre>

<pre><code class="r">x &lt;- seq(-5, 5, length = 100)
plot(x, dnorm(x), type = &#39;l&#39;)
lines(x, dt(x, df = 1), col = &#39;red&#39;)
</code></pre>

<p><img src="data:image/png;base64,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WXGbSJVNmkS//EKNjW1+OGbMmPDwcG4DgbJD0QMXEhISnJyc2v7s++9pyRJu46g4DQ0aN44uXWrzwzFjxly7do3jRKDkUPTAuqKiIgsLi7ZfNtLURGFhNGkS56FU3J//3N7oDV5CAq9D0QPrwsPDfX192/7s4kXy88Ps84z17k319ZSf3+aHAwYMyMrK4jgRKDMUPbCuowH6PXto+XJu4wjFypW0Z0+bn2D0BlpB0QPrkpKSHBwc2vjgzh2ysKBevThPJAiTJtH1622+NBxFD62g6IFdBQUFVlZWbd9B/8UXtGYN54mEQiSiRYvafHhqwIABDx484DwQKC8tDo7RwaWhgQMHchAAeHT16tW2x22KiujJE+r4tYLQsUWLyNeXVq58/SLHwIED7927Z4c5n4GIuCn69957LyQkRF9f38TEpNVHBQUFHAQAHl27dm39+vVtfPDvf9O773IeR1j09cnfn86fpxkzWn3SPHqDoodmXAzdXL58efny5YsXLy54DQdHB361PcVNTQ398gtNncpHImFZs4a+/fb1xRimh5Y4GqN/++23+/fvz82xQHnk5ub27dtXJBK1/uDHH2n+fExuowDdupGlJcXGtlrcu3fv3NxciUTCSyhQNhz9pI0ePXrDhg3cHAuUR9sD9BIJHTpEixfzkUiI1q+nf//79cUODg6pqancxwElxNspVVlZWUhICF9HB25cu3bNz8+v9dLgYBo1igwN+UgkRA4O9OwZ5eS0WozRG3iFi4uxbUpNTQ0ICKipqWlvhRMnTuzatavVwvz8/LbvyAallJmZaWNj03rpV1/R8eN8xBGuTZto50767ruWy3x9fVevXr169Wq+QoHy4K3ovby8Omh5IpozZ86cOXNaLVy3bh0u4aqK9PT0Nm6fPXeO3N3xykAF8/am7dspK4taXAmztLQsLCysr6/X1tbmMRooA06HbiQSSWVlJS4QqYlLly5Nen22sq++or/+lY84Qrd5M336aatlXl5eMTExvMQBpcJF0dfW1m7ZssXOzk5XV9fY2FhHR8fW1nbr1q11dXUcHB34EhYWNrbV2wFxOs8eb2/KzqY/zmU2ceLEy5cv85UIlAcXRb9s2bLk5OSgoKDmXySLiooOHTqUkZGxYsUKDo4OvKipqamvrzczM/vDUpzOs+of/6BPPmm5wMfHJyIigq84oDy4GKO/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" alt=""/></p>

<pre><code class="r">rmultinom(1, 100, prob = c(.1, .1, .2, .3, .25, .05)) 
</code></pre>

<pre><code>##      [,1]
## [1,]    8
## [2,]   11
## [3,]   21
## [4,]   31
## [5,]   24
## [6,]    5
</code></pre>

<pre><code class="r">x &lt;- seq(0, 10, length = 100)
plot(x, dchisq(x, df = 1), type = &#39;l&#39;)
lines(x, dchisq(x, df = 2), col = &#39;red&#39;)
</code></pre>

<p><img src="data:image/png;base64,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" alt=""/></p>

<h1>Other types of simulation and sampling</h1>

<p>We can draw a sample with or without replacement.</p>

<pre><code class="r">sample(1:nrow(gap), 20, replace = FALSE)
</code></pre>

<pre><code>##  [1] 1583 1019  955  895 1675  863 1160 1021  406  438 1236  767  297 1263
## [15]  178 1461 1038  940  555  764
</code></pre>

<p>Here&#39;s an example of some code that would be part of coding up a bootstrap. As I mentioned previously, this would be a weird dataset to do formal statistical inference on given it includes most of the countries in the world, though one could think about fitting models for the variation over time, treating short-term fluctuations as random.</p>

<pre><code class="r"># actual mean
mean(gap$lifeExp, na.rm = TRUE)
</code></pre>

<pre><code>## [1] 59.47444
</code></pre>

<pre><code class="r"># here&#39;s a bootstrap sample:
smp &lt;- sample(seq_len(nrow(gap)), replace = TRUE) 
mean(gap$lifeExp[smp], na.rm = TRUE)
</code></pre>

<pre><code>## [1] 60.10613
</code></pre>

<p>It&#39;s a good idea to use <code>seq_along()</code> and <code>seq_len()</code> and not syntax like <code>1:length(gap)</code> in <code>sample()</code> because the outcome of <code>length()</code> might in some cases be unexpected (e.g., if you&#39;re taking subsets of a dataset). Similar reasoning holds when setting up for loops: e.g., </p>

<pre><code class="r">for(i in seq_len(nrow(gap))) {
# blah
}
</code></pre>

<h1>The Random Seed</h1>

<p>A few key facts about generating random numbers</p>

<ul>
<li>Random number generation is based on generating uniformly between 0 and 1 and then transforming to the kind of random number of interest: normal, categorical, etc.</li>
<li>Random numbers on a computer are <em>pseudo-random</em>; they are generated deterministically from a very, very, very long sequence that repeats</li>
<li>The <em>seed</em> determines where you are in that sequence</li>
</ul>

<p>To replicate any work involving random numbers, make sure to set the seed first.</p>

<pre><code class="r">set.seed(1)
vals &lt;- sample(1:nrow(gap), 10)
vals
</code></pre>

<pre><code>##  [1]  453  634  975 1545  343 1527 1605 1122 1067  105
</code></pre>

<pre><code class="r">vals &lt;- sample(1:nrow(gap), 10)
vals
</code></pre>

<pre><code>##  [1]  351  301 1170  654 1309  846 1219 1684  645 1318
</code></pre>

<pre><code class="r">set.seed(1)
vals &lt;- sample(1:nrow(gap), 10)
vals
</code></pre>

<pre><code>##  [1]  453  634  975 1545  343 1527 1605 1122 1067  105
</code></pre>

<h1>More details on reading data into R</h1>

<p>Remember that you&#39;ll need to know the current working directory so that you know where R is looking for files.</p>

<p>The workhorse for reading into a data frame is <em>read.table()</em>, which allows any separator (CSV, tab-delimited, etc.). <em>read.csv()</em> is a special case of <em>read.table()</em> for CSV files.</p>

<p>You&#39;ve already seen a bit of this, but let&#39;s work through a more involved example, so you can see some of the steps and tricks involved in reading data into R.</p>

<pre><code class="r">rta &lt;- read.table(&quot;../data/RTAData.csv&quot;, sep = &quot;,&quot;, head = TRUE)
rta[1:5, 1:5]
</code></pre>

<pre><code>##               time X40010 X40015 X40020 X40025
## 1 2010-03-01 14:58    821    209    828    258
## 2 2010-03-01 15:01    804    209    804    248
## 3 2010-03-01 15:04    892    212    801    237
## 4 2010-03-01 15:07    857    214    821    243
## 5 2010-03-01 15:10    849    222    834    252
</code></pre>

<pre><code class="r">dim(rta)
</code></pre>

<pre><code>## [1] 120822     62
</code></pre>

<pre><code class="r"># great, we&#39;re all set, right?
# Not so fast...
unlist(lapply(rta, class))[1:5]
</code></pre>

<pre><code>##     time   X40010   X40015   X40020   X40025 
## &quot;factor&quot; &quot;factor&quot; &quot;factor&quot; &quot;factor&quot; &quot;factor&quot;
</code></pre>

<pre><code class="r"># ?read.table
rta2 &lt;- read.table(&quot;../data/RTAData.csv&quot;, sep = &quot;,&quot;, 
  head = TRUE, stringsAsFactors = FALSE)
rta2[3,3]
</code></pre>

<pre><code>## [1] &quot;212&quot;
</code></pre>

<pre><code class="r">unlist(lapply(rta2, class))[1:5]
</code></pre>

<pre><code>##        time      X40010      X40015      X40020      X40025 
## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot;
</code></pre>

<pre><code class="r"># let&#39;s delve more deeply
levels(rta[ , 2])[c(1:5, 3041:3044)]
</code></pre>

<pre><code>## [1] &quot;&quot;     &quot;1000&quot; &quot;1001&quot; &quot;1002&quot; &quot;1003&quot; &quot;997&quot;  &quot;998&quot;  &quot;999&quot;  &quot;x&quot;
</code></pre>

<pre><code class="r">rta3 &lt;- read.table(&quot;../data/RTAData.csv&quot;, sep = &quot;,&quot;, head = TRUE, 
      stringsAsFactors = FALSE, na.strings = c(&#39;NA&#39;, &#39;x&#39;))
unlist(lapply(rta3, class))[1:5]
</code></pre>

<pre><code>##        time      X40010      X40015      X40020      X40025 
## &quot;character&quot;   &quot;integer&quot;   &quot;integer&quot;   &quot;integer&quot;   &quot;integer&quot;
</code></pre>

<pre><code class="r"># checking...
missing &lt;- which(rta[ , 2] == &quot;&quot;)
missing[1:5]
</code></pre>

<pre><code>## [1] 1167 1168 1169 1170 1171
</code></pre>

<pre><code class="r">rta3[head(missing), ]
</code></pre>

<pre><code>##                  time X40010 X40015 X40020 X40025 X40030 X40035 X40040
## 1167 2010-03-04 01:16     NA     NA     NA     NA     NA     NA     NA
## 1168 2010-03-04 01:19     NA     NA     NA     NA     NA     NA     NA
## 1169 2010-03-04 01:22     NA     NA     NA     NA     NA     NA     NA
## 1170 2010-03-04 01:25     NA     NA     NA     NA     NA     NA     NA
## 1171 2010-03-04 01:28     NA     NA     NA     NA     NA     NA     NA
## 1172 2010-03-04 01:31     NA     NA     NA     NA     NA     NA     NA
##      X40045 X40050 X40055 X40060 X40065 X40070 X40075 X40080 X40085 X40090
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1168     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1169     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1170     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1171     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1172     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X40092 X40095 X40100 X40105 X40110 X40115 X40120 X40125 X40130 X40135
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1168     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1169     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1170     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1171     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1172     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X40140 X40145 X40150 X41010 X41015 X41020 X41025 X41030 X41035 X41040
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1168     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1169     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1170     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1171     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1172     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X41045 X41050 X41055 X41060 X41065 X41070 X41075 X41080 X41085 X41090
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1168     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1169     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1170     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1171     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1172     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X41095 X41100 X41105 X41110 X41115 X41120 X41125 X41130 X41135 X41140
## 1167     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1168     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1169     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1170     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1171     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
## 1172     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
##      X41145 X41150 X41155 X41160
## 1167     NA     NA     NA     NA
## 1168     NA     NA     NA     NA
## 1169     NA     NA     NA     NA
## 1170     NA     NA     NA     NA
## 1171     NA     NA     NA     NA
## 1172     NA     NA     NA     NA
</code></pre>

<p>It&#39;s good to first look at your data in plain text format outside of R and then to check it after you&#39;ve read it into R.</p>

<h1>Other ways to read data into R</h1>

<p>The <em>read.table()</em> family of functions just skims the surface of things&hellip;</p>

<p>1) You can also read in a file as vector of characters, one character string per line of the file with <em>readLines()</em>, and then post-process it. 
2) You can read fixed width format (constant number of characters per field) with <em>read.fwf()</em>.
3) <em>read_csv()</em> (and <em>read_lines()</em>, <em>read_fwf()</em>, etc.) in the <em>readr</em> package is a faster, more helpful drop-in replacement for <em>read.csv()</em> that plays well with <em>dplyr</em> (see Module 5).
4) the <em>data.table</em> package is great for reading and manipulating large datasets (orders of gigabytes or 10s of gigabytes).</p>

<h1>Breakout</h1>

<h3>Basics</h3>

<p>1) Extract the 5th row from the gapminder dataset.</p>

<p>2) Extract the last row from the gapminder dataset.</p>

<p>3) Count the number of gdpPercap values greater than 50000 in the gapminder dataset.</p>

<p>4) Set all of the gdpPercap values greater than 50000 to NA. You should probably first copy the <code>gap</code> object and work on the copy so that the dataset is unchanged (or just read the data into R again afterwards to get a clean copy).</p>

<p>5) Consider the first row of the gapminder dataset, which has Afghanistan for 1952. How do I create a string &ldquo;Afghanistan-1952&rdquo; using <code>gap$country[1]</code> and <code>gap$year[1]</code>?</p>

<p>6) Generate 100 random Poisson values with a population mean of 5. How close is the mean of those 100 values to the value of 5?</p>

<p>7) What is the 95th percentile of a chi-square distribution with 1 degree of freedom?</p>

<p>8) What&#39;s the probability of getting a value greater than 5 if you draw from a standard normal distribution? What about a t distribution with 1 degree of freedom?</p>

<h3>Using the ideas</h3>

<p>9) Create a character string using <code>paste()</code> that tells the user how many rows there are in the data frame - do this programmatically such that it would work for any data frame regardless of how many rows it has. The result should look like this: &ldquo;There are 1704 rows in the dataset&rdquo;</p>

<p>10) If you didn&#39;t do it this way already, extract the last row from the gapminder dataset without typing the number &#39;1704&#39;.</p>

<p>11) Create a boolean vector indicating if the life expectancy is greater than 75 and the gdpPercap is less than 10000 and calculate the proportion of all the records these represent.</p>

<p>12) Use that vector to create a new data frame that is a subset of the original data frame.</p>

<p>13) Consider the attributes of the gapminder dataset. What kind of R object is the set of attributes?</p>

<h3>Advanced</h3>

<p>14) Create row names for the data frame based on concatenating the Continent, Country, and Year fields.</p>

</body>

</html>
